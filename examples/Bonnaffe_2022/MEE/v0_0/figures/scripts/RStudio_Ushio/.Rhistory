{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
lines(TS_pred[,1],TS_pred[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
}
#
###
####################
## INITIATE MODEL ##
####################
## model properties
N = ncol(TS) - 1
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_ODE2(t, Y, Beta, I=N, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_ODE2(t, Y, Beta, I=N, O=N)
n_Beta = n_Beta_ODE2(I=N, O=N)
model.predict = model.predict_ODE
output = "out"
## fixed input
idx_Y_0   = function() 1:N
idx_Sigma = function()  N + 1:N
idx_Beta  = function()  N +   N + 1:n_Beta
n_params = length(idx_Y_0()) + length(idx_Sigma()) + length(idx_Beta())
## check
Y_0   = as.numeric(TS[1,-1])
Beta  = runif(n_Beta,-.001,.001)
Sigma = rep(1,N)
TS_pred = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
model.dLogPost(TS,Y_0,Beta,Sigma)
model.dLogPost_wrapper(TS,c(log(Y_0),log(Sigma),Beta))
model.dLogPost_wrapper(TS,model.initiate())
## benchmark
time = system.time(
for(i in 1:1000)
{
model.dLogPost_wrapper(TS,model.initiate())
}
)
print(time)
#
###
# #################
# ## DEMC CHAINS ##
# #################
#
# ## RCpp implementation of DEMCO
# t_train      = 1:20
# t_val        = 21:30
# n_iterations = 60
# n_chains     = 30
# chainList    = list()
# timeVect     = rep(0,n_chains)
# for(l in 1:n_chains)
# {
#   timeVect[l] = system.time({
#
#       ## initiate
#       dTarget = function(x) - model.dLogPost_wrapper(TS=TS[c(t_train),],x)
#       Theta_0 = Theta  = model.initiate()
#       dTarget_0 = - dTarget(Theta_0)
#
#       ## pre-training
#       try(expr = {
#         res     = optim(Theta,dTarget,method="BFGS",control = list("trace"=1,"REPORT"=1,"maxit"=n_iterations))
#         Theta = res$par
#       })
#
#       # ## initiate
#       # dTarget = function(x) - model.dLogPost_wrapper(TS=TS[c(t_train,t_val),],x)
#       #
#       # ## training
#       # try(expr = {
#       #   res     = optim(Theta,dTarget,method="BFGS",control = list("trace"=1,"REPORT"=1,"maxit"=n_iterations))
#       #   Theta = res$par
#       # })
#
#       ## store in change
#       Theta_f = Theta
#       dTarget_f = - dTarget(Theta_f)
#       chainList[[l]] = rbind(c(dTarget_0,Theta_0),c(dTarget_f,Theta_f))
#
#       # ## visualise
#       # model.plot(TS,model.predict_wrapper(Theta))
#       # print(model.dLogPost_wrapper(TS=TS[t_train,], Theta=Theta))
#       # print(model.dLogPost_wrapper(TS=TS[t_val,], Theta=Theta))
#
#     })[3]
# }
#
# ## store chains
# system(paste("rm -r ",output,sep=""))
# system(paste("mkdir ",output,sep=""))
# chainList.write(chainList,output)
# write(x = timeVect, file = paste(output,"/runtimes.txt",sep=""))
#
# #
# ###
######################
## CHAIN PROCESSING ##
######################
## load chains
chainList = chainList.read(output)
chainList_thinned = chainList
## untransform
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
chainList_thinned = chainList_thinned[!is.na(chainList_thinned[,1]),]
chainList_thinned = chainList_thinned[chainList_thinned[,1]>quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
#
###
#############
## FIGURES ##
#############
##
## FIT
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
## avoid na on test set
s = which(is.na(Ybar_ensemble$f_ensemble[,ncol(Ybar_ensemble$f_ensemble)]))
chainList_thinned[[1]] = chainList_thinned[[1]][-s,]
## MaP prediction
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
## figure
pdf(paste(output,"/fit.pdf",sep=""))
#
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = c("green","blue","red")
plot(TS[,1],TS[,2], pch=16, ylim=c(0,3), cex=0,xlab="Time",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1],lty=2)
lines(Ybar_mean[,1],Ybar_mean[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
#
dev.off()
##
## EFFECTS
## compute per-capita growth rate effects and contributions
rhat_pred     = t(apply(Ybar_MaP, 1, function(x) 1/x[-1] * unlist(model.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()]))))
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
geber_pred    = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()]) * unlist(model.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()]))))
## figure
pdf(paste(output,"/effects.pdf",sep=""))
#
## graphical parameters
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
index  = c("a.","b.","c.","d.","e.","f.","g.","h.","i.")
layout(mat = matrix(1:(N*3),nrow=3))
colVect = c("green","blue","red")
#
for(i in 1:N)
{
## per-capita growth rate
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="",ylab=if(i==1)"Growth rate"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,rhat_pred[,i],col=colVect[i])
#
t = t_true
lines(t,rhat_true[,i],col=colVect[i],lty=2)
#
## effects
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3,cex=0,xlab="",ylab=if(i==1)"Effects"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = t_true
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
## geber
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="Time",ylab=if(i==1)"Contributions"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,geber_pred[,1]*0,lty=2)
lines(t,geber_pred[,1+(i-1)*N],col="green")
lines(t,geber_pred[,2+(i-1)*N],col="blue")
lines(t,geber_pred[,3+(i-1)*N],col="red")
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
}
par(mfrow=c(1,1))
#
dev.off()
#
###
############
## OUTPUT ##
############
## goal: store results
## save predictions
results_ODE2 = list("t"=TS[,1]+19, "Yhat_p"=rhat_pred, "ddx.Yhat_p"=ddx.rhat_pred, "Geber_p"=geber_pred)
save(results_ODE2,file=paste(output,"/results_ODE2.RData",sep=""))
#
###
pdf(paste(output,"/fit.pdf",sep=""))
#
par(mfrow=c(1,1),mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
#
colVect = c("green","blue","red")
plot(TS[,1],TS[,2], pch=16, ylim=c(0,3), cex=0,xlab="Time",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1],lty=2)
lines(Ybar_mean[,1],Ybar_mean[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
#
dev.off()
## figure
pdf(paste(output,"/effects.pdf",sep=""))
#
## graphical parameters
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
index  = c("a.","b.","c.","d.","e.","f.","g.","h.","i.")
layout(mat = matrix(1:(N*3),nrow=3))
colVect = c("green","blue","red")
#
for(i in 1:N)
{
## per-capita growth rate
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="",ylab=if(i==1)"Growth rate"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,rhat_pred[,i],col=colVect[i])
#
t = t_true
lines(t,rhat_true[,i],col=colVect[i],lty=2)
#
## effects
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3,cex=0,xlab="",ylab=if(i==1)"Effects"else"",cex.lab=1.5)
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*(3)],bty="n",cex=1.5)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = t_true
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[2+(i-1)*(3)],bty="n",cex=1.5)
#
## geber
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="Time",ylab=if(i==1)"Contributions"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,geber_pred[,1]*0,lty=2)
lines(t,geber_pred[,1+(i-1)*N],col="green")
lines(t,geber_pred[,2+(i-1)*N],col="blue")
lines(t,geber_pred[,3+(i-1)*N],col="red")
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[3+(i-1)*(3)],bty="n",cex=1.5)
}
par(mfrow=c(1,1))
#
dev.off()
## figure
pdf(paste(output,"/effects.pdf",sep=""))
#
## graphical parameters
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
index  = c("a.","b.","c.","d.","e.","f.","g.","h.","i.")
layout(mat = matrix(1:(N*3),nrow=3))
colVect = c("green","blue","red")
#
for(i in 1:N)
{
## per-capita growth rate
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="",ylab=if(i==1)"Growth rate"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,rhat_pred[,i],col=colVect[i])
#
t = t_true
lines(t,rhat_true[,i],col=colVect[i],lty=2)
#
## effects
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3,cex=0,xlab="",ylab=if(i==1)"Effects"else"",cex.lab=1.5)
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*(3)],bty="n",cex=1.5)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = t_true
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[2+(i-1)*(3)],bty="n",cex=1.5)
#
## geber
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="Time",ylab=if(i==1)"Contributions"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,geber_pred[,1]*0,lty=2)
lines(t,geber_pred[,1+(i-1)*N],col="green")
lines(t,geber_pred[,2+(i-1)*N],col="blue")
lines(t,geber_pred[,3+(i-1)*N],col="red")
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[3+(i-1)*(3)],bty="n",cex=1.5)
}
par(mfrow=c(1,1))
#
dev.off()
## figure
pdf(paste(output,"/effects.pdf",sep=""))
#
## graphical parameters
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
index  = c("a.","b.","c.","d.","e.","f.","g.","h.","i.")
layout(mat = matrix(1:(N*3),nrow=3))
colVect = c("green","blue","red")
#
for(i in 1:N)
{
## per-capita growth rate
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="",ylab=if(i==1)"Growth rate"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,rhat_pred[,i],col=colVect[i])
#
t = t_true
lines(t,rhat_true[,i],col=colVect[i],lty=2)
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*(3)],bty="n",cex=1.5)
#
## effects
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3,cex=0,xlab="",ylab=if(i==1)"Effects"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = t_true
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[2+(i-1)*(3)],bty="n",cex=1.5)
#
## geber
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1),cex=0,xlab="Time",ylab=if(i==1)"Contributions"else"",cex.lab=1.5)
#
t = TS[,1] + 19
lines(t,geber_pred[,1]*0,lty=2)
lines(t,geber_pred[,1+(i-1)*N],col="green")
lines(t,geber_pred[,2+(i-1)*N],col="blue")
lines(t,geber_pred[,3+(i-1)*N],col="red")
#
legend("bottom",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
if(!is.null(index)) legend("topright",legend=index[3+(i-1)*(3)],bty="n",cex=1.5)
}
par(mfrow=c(1,1))
#
dev.off()
#
setwd("~/Documents/GitHub/NODERGM/examples/Bonnaffe_2022/MEE/v0_0/figures/scripts/RStudio_Ushio")
############
## goal: load data, functions
## load NODEBNGM functions
source("f_NODE_GM_Rstudio.r")
## load data
TS = read.table("data/TS.csv",sep=",",header=T)
## extract time steps and columns of interest
selected_time_steps = 50:150
selected_columns  = c(
"time_step",
# "surf.t",
"bot.t",
"Aurelia.sp",
# "Engraulis.japonicus", #
# "Plotosus.lineatus", #
"Sebastes.inermis",
"Trachurus.japonicus",
"Girella.punctata",
"Pseudolabrus.sieboldi",
"Halichoeres.poecilopterus",
"Halichoeres.tenuispinnis",
# "Chaenogobius.gulosus", #
"Pterogobius.zonoleucus",
"Tridentiger.trigonocephalus",
# "Siganus.fuscescens", #
"Sphyraena.pinguis", #
"Rudarius.ercodes"
)
TS = TS[selected_time_steps,]
TS = TS[,selected_columns]
## shorten column names
column_names =  c("time_step",
"bot.t",
"Aurel.sp",
"S.inerm.",
"T.japon.",
"G.punct.",
"P.siebo.",
"H.poeci.",
"H.tenui.",
"P.zonol.",
"T.trigo.",
"S.pingu.",
"R.ercod."
)
colnames(TS) = column_names
## normalise time series
TS[,-1] = apply(TS[,-1],2,function(x)(x-min(x))/(max(x)-min(x))*10)
## set 0s to small value to avoid NAs
for(i in 2:ncol(TS)){TS[,i][which(TS[,i]<0.005)] = 0.005}
## make output directory
pathToOut = "out_4"
system(paste("mkdir",pathToOut))
## visualise time series
pdf(paste(pathToOut,"/fig_time_series.pdf",sep=""))
par(mfrow=c(3,4))
for(i in 2:ncol(TS))
{
plot(TS[,1],TS[,i],type="l",xlab="Time step",ylab="Relative density",bty="n",main=colnames(TS)[i])
}
par(mfrow=c(1,1))
dev.off()
load(paste(pathToOut,"/","Yhat_p.RData"    ,sep=""))
load(paste(pathToOut,"/","ddx.Yhat_p.RData",sep=""))
load(paste(pathToOut,"/","Geber_p.RData"   ,sep=""))
load(paste(pathToOut,"/","Omega_p.RData"   ,sep=""))
pathToOut = "out"
system(paste("mkdir",pathToOut))
## visualise time series
pdf(paste(pathToOut,"/fig_time_series.pdf",sep=""))
par(mfrow=c(3,4))
for(i in 2:ncol(TS))
{
plot(TS[,1],TS[,i],type="l",xlab="Time step",ylab="Relative density",bty="n",main=colnames(TS)[i])
}
par(mfrow=c(1,1))
dev.off()
## load results process model
load(paste(pathToOut,"/","Yhat_p.RData"    ,sep=""))
load(paste(pathToOut,"/","ddx.Yhat_p.RData",sep=""))
load(paste(pathToOut,"/","Geber_p.RData"   ,sep=""))
load(paste(pathToOut,"/","Omega_p.RData"   ,sep=""))
Yhat_p[[1]]
## remove drivers of temperature as not driven by variables
Yhat_p[[1]]     = Yhat_p[[1]]*0
ddx.Yhat_p[[1]] = ddx.Yhat_p[[1]]*0
Geber_p[[1]]    = Geber_p[[1]]*0
Omega_p[[1]]    = Omega_p[[1]]*0
## parameters of observation model
N       = ncol(TS) - 1
K_o     = 100                # number of ensemble elements
W_o     = rep(30,N)          # number of neurons in observation model, by default a single layer perceptron (equivalent to number of elements in Fourier series)
N_o     = W_o*3              # total number of parameters in observation model
rho     = 1                  # proportion of best samples to reject (to refine quality of fit if necessary)
alpha_i = 1                  # upsampling interpolation factor (2 double the number of points in interpolated time series)
## parameters of process model
K_p   = 30                                                      # number of models to fit
W_p   = rep(10,N)                                               # number of neurons in single layer perceptron (SLP)
N_p   = 2 * W_p * (2+N)                                         # number of parameters in process model
sd1_p = 0.1                                                     # standard deviation of model likelihood
sd2_p = as.list(rep(0.03,N))                                    # standard deviation of prior distributions (second half concerns nonlinear functions)
## load model_o
load(file=paste(pathToOut,"/","Yhat_o.RData"    ,sep=""))
load(file=paste(pathToOut,"/","ddt.Yhat_o.RData",sep=""))
load(file=paste(pathToOut,"/","Omega_o.RData"   ,sep=""))
## visualise process model
pdf(paste(pathToOut,"/fig_predictions_p.pdf",sep=""))
plotModel_p(TS,alpha_i,Yhat_p,ddx.Yhat_p,Geber_p)
dev.off()
