chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0, # initiate from the priors
epsilon = 0.001,
lambda  = 100,
nIt     = 2000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
## predictions
MaP  = as.numeric(chainList.argmaxPost(chainList))
Y_0  = MaP[idx_Y_0]
Beta = MaP[idx_Beta]
Ybar_ = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=c("red","blue","orange")[i-1])
lines(Ybar_[,1],Ybar_[,i], col=c("red","blue","orange")[i-1])
# polygon(x=c(Ybar[,1],rev(Ybar[,1])), y=c(qgamma(p=0.05,shape=Ybar[,i],1),rev(qgamma(p=0.95,shape=Ybar[,i],1))), border=NA, col=grey(0.75,alpha=0.5))
}
legend("top",legend=c("X","Y","Z"),col=c("red","blue","orange"),lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
## RCpp implementation of DEMC
Theta_0 = MaP
timeVect[1] = system.time(
for(i in 1:1)
{
# Theta_0 = initiate()
# Theta_0 = Theta_0
dTarget = function(x) dLogPost_wrapper(TS=TS,x)
chainList[[i]] = DEMCpp(list(dTarget = dTarget,
Theta_0 = Theta_0, # initiate from the priors
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
nIt     = 2000))[["chainList"]]
})[3]
MaP = chainList.argmaxPost(chainList)
## untransform
for(l in 1:length(chainList))
{
chainList[[l]][,-1][,idx_Y_0]  = exp(chainList[[l]][,-1][,idx_Y_0])
chainList[[l]][,-1][,idx_Sigma] = exp(chainList[[l]][,-1][,idx_Sigma])
chainList[[l]][,-1][,idx_Beta]  = chainList[[l]][,-1][,idx_Beta]
}
## RCpp implementation of DEMC
chainList = list()
timeVect = c(0)
Theta_0 = MaP
timeVect[1] = system.time(
for(i in 1:1)
{
# Theta_0 = initiate()
# Theta_0 = Theta_0
dTarget = function(x) dLogPost_wrapper(TS=TS,x)
chainList[[i]] = DEMCpp(list(dTarget = dTarget,
Theta_0 = Theta_0, # initiate from the priors
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
nIt     = 10000))[["chainList"]]
})[3]
MaP = chainList.argmaxPost(chainList)
## untransform
for(l in 1:length(chainList))
{
chainList[[l]][,-1][,idx_Y_0]  = exp(chainList[[l]][,-1][,idx_Y_0])
chainList[[l]][,-1][,idx_Sigma] = exp(chainList[[l]][,-1][,idx_Sigma])
chainList[[l]][,-1][,idx_Beta]  = chainList[[l]][,-1][,idx_Beta]
}
## predictions
MaP  = as.numeric(chainList.argmaxPost(chainList))
Y_0  = MaP[idx_Y_0]
Beta = MaP[idx_Beta]
Ybar_ = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=c("red","blue","orange")[i-1])
lines(Ybar_[,1],Ybar_[,i], col=c("red","blue","orange")[i-1])
# polygon(x=c(Ybar[,1],rev(Ybar[,1])), y=c(qgamma(p=0.05,shape=Ybar[,i],1),rev(qgamma(p=0.95,shape=Ybar[,i],1))), border=NA, col=grey(0.75,alpha=0.5))
}
legend("top",legend=c("X","Y","Z"),col=c("red","blue","orange"),lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
#
###
## traces MC
chainList.tracePlot(chainList)
chainList.tracePlot(chainList.thin(chainList.burn(chainList,1:500)))
## traces MC
brunin = c(1:5000)
chainList.tracePlot(chainList)
chainList.tracePlot(chainList.thin(chainList.burn(chainList,burnin)))
## traces MC
burnin = c(1:5000)
chainList.tracePlot(chainList.thin(chainList.burn(chainList,burnin)))
## plot posterior distribution DEMC
chainList.postPlot(chainList.thin(chainList.burn(chainList,burnin)),1000)
par(mfrow=c(3,4))
chainList.acPlot(chainList.burn(chainList,burnin))
par(mfrow=c(1,1))
## MaP prediction
MaP  = as.numeric(chainList.argmaxPost(chainList))
Y_0  = MaP[idx_Y_0]
Beta = MaP[idx_Beta]
Ybar_MaP = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList,f = function(x) Ybar(times = TS[,1], Y_0 = x[idx_Y_0], dYdt = dYdt, Beta = x[idx_Beta]))
chainList_thinned = chainList.thin(chainList.burn(chainList,burnin))
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) Ybar(times = TS[,1], Y_0 = x[idx_Y_0], dYdt = dYdt, Beta = x[idx_Beta]))
dim(Ybar_ensemble)
length(Ybar_ensemble)
Ybar_ensemble
length(chainList_thinned)
Ybar_ensemble[[1]]
Ybar_ensemble[[2]]
Ybar_ensemble[[3]]
chainList_thinned
Ybar_q05 = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q05
Ybar_q95 = matrix(Ybar_ensemble[[3]],ncol=N+1)
Ybar_q95
MaP  = as.numeric(chainList.argmaxPost(chainList))
Y_0  = MaP[idx_Y_0]
Beta = MaP[idx_Beta]
Ybar_MaP = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=c("red","blue","orange")[i-1])
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=c("red","blue","orange")[i-1])
polygon(x=c(Ybar_ensemble[,1],rev(Ybar_ensemble[,1])), y=c(qgamma(p=0.05,shape=Ybar[,i],1),rev(qgamma(p=0.95,shape=Ybar[,i],1))), border=NA, col=grey(0.75,alpha=0.5))
}
legend("top",legend=c("X","Y","Z"),col=c("red","blue","orange"),lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=c("red","blue","orange")[i-1])
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=c("red","blue","orange")[i-1])
# polygon(x=c(Ybar_ensemble[,1],rev(Ybar_ensemble[,1])), y=c(qgamma(p=0.05,shape=Ybar[,i],1),rev(qgamma(p=0.95,shape=Ybar[,i],1))), border=NA, col=grey(0.75,alpha=0.5))
}
legend("top",legend=c("X","Y","Z"),col=c("red","blue","orange"),lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) Ybar(times = TS[,1], Y_0 = x[idx_Y_0], dYdt = dYdt, Beta = x[idx_Beta]))
Ybar_q05 = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95 = matrix(Ybar_ensemble[[3]],ncol=N+1)
Ybar_q05
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) Ybar(times = TS[,1], Y_0 = x[-1][idx_Y_0], dYdt = dYdt, Beta = x[-1][idx_Beta]))
Ybar_q05 = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95 = matrix(Ybar_ensemble[[3]],ncol=N+1)
Ybar_q05
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=c("red","blue","orange")[i-1])
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=c("red","blue","orange")[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
}
legend("top",legend=c("X","Y","Z"),col=c("red","blue","orange"),lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
k = 1
mainVect =c("a.","b.")
colVect = rainbow(N)
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=c("X","Y","Z"),col=colVect,lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
## store chains
chainList.write(chainList,"out")
## load data
TS = as.matrix(read.table("data/TS_1.csv",sep=";",header=T))
TS[,1] = TS[,1]-min(TS[,1])
N = ncol(TS) - 1
N
TS
TS[TS[,-1]<0.005,-1] = 0.005
TS
TS[,-1]<0.005
TS[TS[,-1]<0.005,-1]
which(TS[,-1]<0.005)
TS[TS[,-1]<0.005] = 0.005
TS
TS[TS<0.005] = 0.005
TS
## load data
TS = as.matrix(read.table("data/TS_1.csv",sep=";",header=T))
TS[,1] = TS[,1]-min(TS[,1])
N = ncol(TS) - 1
TS[,-1][TS[,-1]<0.005] = 0.005
TS
## model properties
idx_Y_0   = 1:N
idx_Sigma =   N + 1:N
idx_Beta  =   N +   N + 1:(N^2)
## dynamics
dYdt = function(t, Y, Beta)
{
J = matrix(Beta,ncol=length(Y))
dYdt = (J%*%Y)*Y
return(list(dYdt))
}
## predictive function
Ybar = function(times, Y_0, dYdt, Beta)
{
return(ode(y=Y_0, times=times, func=dYdt, parms=Beta, method="ode23"))
}
## posterior
dLogPost = function(TS, Ybar, Y_0, Beta, Sigma)
{
## global parameters
N = ncol(TS) - 1
## predictive function
TS_pred = Ybar(times=TS[,1], Y_0=Y_0, dYdt=dYdt, Beta=Beta)
## calculate posterior
log_lik = sum(log(dnorm(log(TS[,-1]),log(TS_pred[,-1]),Sigma)))
log_pri = sum(log(dunif(Beta,-10,10))) + sum(log(dnorm(log(Sigma),.5,.5)))
log_pos = log_lik + log_pri
# ## debug
# print(log_pos)
# print(log_lik)
# print(log_pri)
## terminate
return(log_pos)
}
## wrapper
dLogPost_wrapper = function(TS,paramVect)
{
Y_0   = exp(paramVect[idx_Y_0])
Sigma = exp(paramVect[idx_Sigma])
Beta = paramVect[idx_Beta]
res = dLogPost(TS, Ybar, Y_0, Beta, Sigma)
if(!is.nan(res) & !is.na(res)){return(res)}else{return(-Inf)}
}
## DEMC wrapper
dTarget = function(x)
{
return(dLogPost_wrapper(TS=TS,x))
}
## initiate function
initiate = function()
{
check = F
while(check == F)
{
Y_0   = TS[1,-1]
Beta  = runif(N^2,-.01,.01)
Sigma = runif(N,0,3)
Theta_0 = c(log(Y_0),log(Sigma),Beta)
# names(Beta_0) = c("V1","V2","V3","V4")
if(dTarget(Theta_0) > -Inf){check = T}
}
return(Theta_0)
}
## debug
Y_0   = TS[1,-1]
Beta  = runif(N^2,-.01,.01)
Sigma = rep(1,N)
TS_pred = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
dLogPost(TS,Ybar,Y_0,Beta,Sigma)
dTarget(c(log(Y_0),log(Sigma),Beta)) # checks out
dTarget(initiate())
## benchmark
timeVect = c(0,0)
chainList = list()
Theta_0 = initiate()
tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 2000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
chainList = list()
Theta_0 = initiate()
tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
chainList = list()
Theta_0 = initiate()
tmax    = c(seq(15,20,2),seq(20,30,5))
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
chainList = list()
Theta_0 = initiate()
# tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
tmax = c(10,20,30)
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
## RCpp implementation of DEMCO
chainList = list()
Theta_0 = initiate()
# tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
tmax = c(10,20,30,40,50,60)
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
## RCpp implementation of DEMCO
chainList = list()
Theta_0 = initiate()
# tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
tmax = c(10,20,30,40,50,60)
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
## RCpp implementation of DEMCO
chainList = list()
Theta_0 = initiate()
# tmax    = c(seq(10,15,1),seq(15,20,2),seq(20,30,5))
tmax = c(10,20,30,40,50,60)
timeVect[1] = system.time(
for(i in 1:length(tmax))
{
dTarget = function(x) dLogPost_wrapper(TS=TS[1:tmax[i],],x)
chainList[[i]] = DEMCOpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
lambda  = 100,
nIt     = 1000))[["chainList"]]
Theta_0 = chainList.argmaxPost(chainList)
})[3]
MaP = chainList.argmaxPost(chainList)
chainList = list()
timeVect = c(0)
Theta_0 = MaP
timeVect[2] = system.time(
for(i in 1:1)
{
# Theta_0 = initiate()
# Theta_0 = Theta_0
dTarget = function(x) dLogPost_wrapper(TS=TS,x)
chainList[[i]] = DEMCpp(list(dTarget = dTarget,
Theta_0 = Theta_0,
gamma   = 2.38/sqrt(2*N),
epsilon = 0.001,
nIt     = 10000))[["chainList"]]
})[3]
MaP = chainList.argmaxPost(chainList)
## untransform
for(l in 1:length(chainList))
{
chainList[[l]][,-1][,idx_Y_0]  = exp(chainList[[l]][,-1][,idx_Y_0])
chainList[[l]][,-1][,idx_Sigma] = exp(chainList[[l]][,-1][,idx_Sigma])
chainList[[l]][,-1][,idx_Beta]  = chainList[[l]][,-1][,idx_Beta]
}
chainList.tracePlot(chainList)
## traces MC
burnin = c(1:5000)
chainList.tracePlot(chainList)
chainList.tracePlot(chainList.thin(chainList.burn(chainList,burnin)))
## plot posterior distribution DEMC
chainList.postPlot(chainList.thin(chainList.burn(chainList,burnin)),1000)
par(mfrow=c(3,4))
chainList.acPlot(chainList.burn(chainList,burnin))
par(mfrow=c(1,1))
## thin
chainList_thinned = chainList.thin(chainList.burn(chainList,burnin))
MaP  = as.numeric(chainList.argmaxPost(chainList))
Y_0  = MaP[idx_Y_0]
Beta = MaP[idx_Beta]
Ybar_MaP = Ybar(times = TS[,1], Y_0 = Y_0, dYdt = dYdt, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) Ybar(times = TS[,1], Y_0 = x[-1][idx_Y_0], dYdt = dYdt, Beta = x[-1][idx_Beta]))
Ybar_q05 = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95 = matrix(Ybar_ensemble[[3]],ncol=N+1)
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
k = 1
mainVect =c("a.","b.")
colVect = rainbow(N)
plot(Y[,1],Y[,2], pch=16, ylim=c(0,max(Y[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(Y[,1],Y[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=c("X","Y","Z"),col=colVect,lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
k = 1
mainVect =c("a.","b.")
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=c("X","Y","Z"),col=colVect,lty=1,horiz=T,bty="n")
legend("topright",legend=mainVect[k],bty="n",cex=1.5)
k = k + 1
#
par(mfrow=c(1,1))
