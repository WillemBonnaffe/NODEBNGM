Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
#
## com^pute effects
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
#
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
n_Beta = n_Beta_NODE(I=N,W=10, O=N)
model.predict = model.predict_ODE
output = "out_NODE"
## model properties
N = ncol(TS) - 1
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_ODE2(t, Y, Beta, I=N, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_ODE2(t, Y, Beta, I=N, O=N)
n_Beta = n_Beta_ODE2(I=N, O=N)
model.predict = model.predict_ODE
output = "out_ODE2"
# ## define model.dYdt
# model.dYdt = function(t, Y, Beta) model.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
# model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
# n_Beta = n_Beta_NODE(I=N,W=10, O=N)
# model.predict = model.predict_ODE
# output = "out_NODE"
## fixed input
idx_Y_0   = function() 1:N
idx_Sigma = function()  N + 1:N
idx_Beta  = function()  N +   N + 1:n_Beta
n_params = length(idx_Y_0()) + length(idx_Sigma()) + length(idx_Beta())
## debug
Y_0   = as.numeric(TS[1,-1])
Beta  = runif(n_Beta,-.001,.001)
Sigma = rep(1,N)
TS_pred = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
model.dLogPost(TS,Y_0,Beta,Sigma)
model.dLogPost_wrapper(TS,c(log(Y_0),log(Sigma),Beta))
model.dLogPost_wrapper(TS,model.initiate())
chainList = chainList.read(output)
chainList_thinned = chainList
## untransform
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
# chainList_thinned = chainList_thinned[chainList_thinned[,1]>-Inf,]
chainList_thinned = chainList_thinned[chainList_thinned[,1]<quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
## MaP prediction
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
#
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
## load chains
chainList = chainList.read(output)
chainList_thinned = chainList
output
chainList_thinned = chainList
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
# chainList_thinned = chainList_thinned[chainList_thinned[,1]<quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
chainList_thinned[,1]
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
chainList_thinned[,1]
chainList_thinned = chainList_thinned[chainList_thinned[,1]>quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
## MaP prediction
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
## com^pute effects
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
#
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
## model properties
N = ncol(TS) - 1
# ## define model.dYdt
# model.dYdt = function(t, Y, Beta) model.dYdt_ODE2(t, Y, Beta, I=N, O=N)
# model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_ODE2(t, Y, Beta, I=N, O=N)
# n_Beta = n_Beta_ODE2(I=N, O=N)
# model.predict = model.predict_ODE
# output = "out_ODE2"
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
n_Beta = n_Beta_NODE(I=N,W=10, O=N)
model.predict = model.predict_ODE
output = "out_NODE"
## fixed input
idx_Y_0   = function() 1:N
idx_Sigma = function()  N + 1:N
idx_Beta  = function()  N +   N + 1:n_Beta
n_params = length(idx_Y_0()) + length(idx_Sigma()) + length(idx_Beta())
## debug
Y_0   = as.numeric(TS[1,-1])
Beta  = runif(n_Beta,-.001,.001)
Sigma = rep(1,N)
TS_pred = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
model.dLogPost(TS,Y_0,Beta,Sigma)
model.dLogPost_wrapper(TS,c(log(Y_0),log(Sigma),Beta))
model.dLogPost_wrapper(TS,model.initiate())
## benchmark
time = system.time(
for(i in 1:1000)
{
model.dLogPost_wrapper(TS,model.initiate())
}
)
print(time)
######################
## DEMC DIAGNOSTICS ##
######################
## load chains
chainList = chainList.read(output)
chainList_thinned = chainList
## untransform
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
chainList_thinned = chainList_thinned[chainList_thinned[,1]>quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
#
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
## model properties
N = ncol(TS) - 1
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_ODE2(t, Y, Beta, I=N, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_ODE2(t, Y, Beta, I=N, O=N)
n_Beta = n_Beta_ODE2(I=N, O=N)
model.predict = model.predict_ODE
output = "out_ODE2"
# ## define model.dYdt
# model.dYdt = function(t, Y, Beta) model.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
# model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
# n_Beta = n_Beta_NODE(I=N,W=10, O=N)
# model.predict = model.predict_ODE
# output = "out_NODE"
## fixed input
idx_Y_0   = function() 1:N
idx_Sigma = function()  N + 1:N
idx_Beta  = function()  N +   N + 1:n_Beta
n_params = length(idx_Y_0()) + length(idx_Sigma()) + length(idx_Beta())
## debug
Y_0   = as.numeric(TS[1,-1])
Beta  = runif(n_Beta,-.001,.001)
Sigma = rep(1,N)
TS_pred = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
model.dLogPost(TS,Y_0,Beta,Sigma)
model.dLogPost_wrapper(TS,c(log(Y_0),log(Sigma),Beta))
model.dLogPost_wrapper(TS,model.initiate())
## benchmark
time = system.time(
for(i in 1:1000)
{
model.dLogPost_wrapper(TS,model.initiate())
}
)
print(time)
## load chains
chainList = chainList.read(output)
chainList_thinned = chainList
## untransform
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
chainList_thinned = chainList_thinned[chainList_thinned[,1]>quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
#
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
## model properties
N = ncol(TS) - 1
# ## define model.dYdt
# model.dYdt = function(t, Y, Beta) model.dYdt_ODE2(t, Y, Beta, I=N, O=N)
# model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_ODE2(t, Y, Beta, I=N, O=N)
# n_Beta = n_Beta_ODE2(I=N, O=N)
# model.predict = model.predict_ODE
# output = "out_ODE2"
## define model.dYdt
model.dYdt = function(t, Y, Beta) model.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
model.ddx.dYdt = function(t, Y, Beta) model.ddx.dYdt_NODE(t, Y, Beta, I=N, W=10, O=N)
n_Beta = n_Beta_NODE(I=N,W=10, O=N)
model.predict = model.predict_ODE
output = "out_NODE"
## fixed input
idx_Y_0   = function() 1:N
idx_Sigma = function()  N + 1:N
idx_Beta  = function()  N +   N + 1:n_Beta
n_params = length(idx_Y_0()) + length(idx_Sigma()) + length(idx_Beta())
## debug
Y_0   = as.numeric(TS[1,-1])
Beta  = runif(n_Beta,-.001,.001)
Sigma = rep(1,N)
TS_pred = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
model.dLogPost(TS,Y_0,Beta,Sigma)
model.dLogPost_wrapper(TS,c(log(Y_0),log(Sigma),Beta))
model.dLogPost_wrapper(TS,model.initiate())
## load chains
chainList = chainList.read(output)
chainList_thinned = chainList
## untransform
for(l in 1:length(chainList_thinned))
{
chainList_thinned[[l]][,-1][,idx_Y_0()]  = exp(chainList_thinned[[l]][,-1][,idx_Y_0()])
chainList_thinned[[l]][,-1][,idx_Sigma()] = exp(chainList_thinned[[l]][,-1][,idx_Sigma()])
chainList_thinned[[l]][,-1][,idx_Beta()]  = chainList_thinned[[l]][,-1][,idx_Beta()]
}
## group chains
chainList_thinned = chainList.unlist(chainList_thinned)
chainList_thinned = chainList_thinned[chainList_thinned[,1]>quantile(x=chainList_thinned[,1], p=0.75),]
chainList_thinned = list(chainList_thinned)
## MaP prediction
MaP  = as.numeric(chainList.argmaxPost(chainList_thinned))
Y_0  = MaP[idx_Y_0()]
Beta = MaP[idx_Beta()]
Ybar_MaP = model.predict(times = TS[,1], Y_0 = Y_0, Beta = Beta)
#
## ensemble predictions
Ybar_ensemble = chainList.apply(chainList_thinned,f = function(x) model.predict(times = TS[,1], Y_0 = x[-1][idx_Y_0()], Beta = x[-1][idx_Beta()]))
Ybar_mean = matrix(Ybar_ensemble[[1]],ncol=N+1)
Ybar_q05  = matrix(Ybar_ensemble[[2]],ncol=N+1)
Ybar_q95  = matrix(Ybar_ensemble[[3]],ncol=N+1)
#
## plot
par(mfrow=c(1,1),mar=c(5,5,0,0),oma=c(0,0,1,1))
#
colVect = rainbow(N)
plot(TS[,1],TS[,2], pch=16, ylim=c(0,max(TS[,-1])), cex=0,xlab="",ylab="Density")
for(i in 2:4)
{
points(TS[,1],TS[,i], pch=16, col=colVect[i-1])
polygon(x=c(Ybar_q05[,1],rev(Ybar_q05[,1])), y=c(Ybar_q05[,i],rev(Ybar_q95[,i])), border=NA, col=grey(0.75,alpha=0.5))
lines(Ybar_MaP[,1],Ybar_MaP[,i], col=colVect[i-1])
}
legend("top",legend=colnames(TS)[-1],col=colVect,lty=1,horiz=T,bty="n")
#
par(mfrow=c(1,1))
ddx.rhat_pred = t(apply(Ybar_MaP, 1, function(x) model.ddx.dYdt(t = x[1], Y = x[-1], Beta = MaP[idx_Beta()])))
#
##
par(mfrow=c(2,N))
#
for(i in 1:N)
{
plot(1:10,xlim=c(20,50)-1,ylim=c(-1,1)*3.5,cex=0)
#
t = TS[,1] + 19
lines(t,ddx.rhat_pred[,1]*0,lty=2)
lines(t,ddx.rhat_pred[,1+(i-1)*N],col="green")
lines(t,ddx.rhat_pred[,2+(i-1)*N],col="blue")
lines(t,ddx.rhat_pred[,3+(i-1)*N],col="red")
#
t = ddx.rhat_true_t
lines(t,ddx.rhat_true[,1+(i-1)*N],col="green",lty=2)
lines(t,ddx.rhat_true[,2+(i-1)*N],col="blue",lty=2)
lines(t,ddx.rhat_true[,3+(i-1)*N],col="red",lty=2)
}
par(mfrow=c(1,1))
#
