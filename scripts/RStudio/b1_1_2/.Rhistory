Yhat_o
ddt.Yhat_o
x = c(1,2,3)
apply(x,2,mean)
apply(t(x),2,mean)
apply(diff,2,TS)
apply(TS,2,diff)
ddt.Yhat_o = apply(TS,2,diff)
Yhat_o    = TS
ddt.Yhat_o = apply(TS,2,diff)
##
Yhat_o_     = TS
ddt.Yhat_o_ = apply(TS,2,diff)
Yhat_o = list()
ddt.Yhat_o = list()
for(i in 1:N)
{
Yhat_o[[i]] = t(Yhat_o_[,i])
ddt.Yhat_o[[i]] = t(ddt.Yhat_o_[,i])
}
Yhat_o[[i]]
plotModel_o(TS,alpha_i,Yhat_o,ddt.Yhat_o)
apply(Yhat_o[[i]],2,mean)
i
E.Yhat_o       = apply(Yhat_o[[i]],2,mean)
q05.Yhat_o     = apply(Yhat_o[[i]],2,quantile,p=0.05)
q95.Yhat_o     = apply(Yhat_o[[i]],2,quantile,p=0.95)
E.ddt.Yhat_o   = apply(ddt.Yhat_o[[i]],2,mean)
q05.ddt.Yhat_o = apply(ddt.Yhat_o[[i]],2,quantile,p=0.05)
q95.ddt.Yhat_o = apply(ddt.Yhat_o[[i]],2,quantile,p=0.95)
#
## training data
t = TS[,1]
Y = TS[,-1][,i]
nt = seq(min(t),max(t),(t[2]-t[1])/alpha_i)
#
## visualise interpolated response
plot(t,rep(0,length(t)),ylim=c(min(Y)-0.2,max(Y))+0.2*c(-min(Y),max(Y)),type="l",lty=3,xlab=xlab[1],ylab=if(i == 1)ylab[1]else"")
col   = (rainbow(N,start=0.1,end=0.9))
xlab  = c("","Time")
ylab  = c("Y(t)","dY/dt(t)")
index = c("a.","b.","c.","d.","e.","f.","g.","h.","i.","j.","k.","l.","m.","n.","o.","p.","q.","r.","s.","t.","u.","v.","w.","x.","y.","z.")
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
layout(cbind(c(1,2),c(3,4),c(5,6))[,1:min(3,N)])
#
## visualise interpolated response
plot(t,rep(0,length(t)),ylim=c(min(Y)-0.2,max(Y))+0.2*c(-min(Y),max(Y)),type="l",lty=3,xlab=xlab[1],ylab=if(i == 1)ylab[1]else"")
polygon(c(nt,rev(nt)),c(q05.Yhat_o,rev(q95.Yhat_o)),col=adjustcolor(col[i],alpha=0.25),border=NA)
lines(nt,E.Yhat_o,col=adjustcolor(col[i],0.75),lwd=2)
points(t,Y,pch=16,col=adjustcolor("black",0.75))
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*2],bty="n",cex=1.5)
legend("bottom",legend=colnames(TS)[-1][i],lty=1,col=col[i],lwd=2,bty="n",horiz=T)
TS
head(TS)
##
Yhat_o_     = TS[,-1]
ddt.Yhat_o_ = apply(TS[,-1],2,diff)
Yhat_o = list()
ddt.Yhat_o = list()
for(i in 1:N)
{
Yhat_o[[i]] = t(Yhat_o_[,i])
ddt.Yhat_o[[i]] = t(ddt.Yhat_o_[,i])
}
plotModel_o(TS,alpha_i,Yhat_o,ddt.Yhat_o)
## predictions
E.Yhat_o       = apply(Yhat_o[[i]],2,mean)
q05.Yhat_o     = apply(Yhat_o[[i]],2,quantile,p=0.05)
q95.Yhat_o     = apply(Yhat_o[[i]],2,quantile,p=0.95)
E.ddt.Yhat_o   = apply(ddt.Yhat_o[[i]],2,mean)
q05.ddt.Yhat_o = apply(ddt.Yhat_o[[i]],2,quantile,p=0.05)
q95.ddt.Yhat_o = apply(ddt.Yhat_o[[i]],2,quantile,p=0.95)
#
## training data
t = TS[,1]
Y = TS[,-1][,i]
nt = seq(min(t),max(t),(t[2]-t[1])/alpha_i)
#
#
## visualise interpolated response
plot(t,rep(0,length(t)),ylim=c(min(Y)-0.2,max(Y))+0.2*c(-min(Y),max(Y)),type="l",lty=3,xlab=xlab[1],ylab=if(i == 1)ylab[1]else"")
polygon(c(nt,rev(nt)),c(q05.Yhat_o,rev(q95.Yhat_o)),col=adjustcolor(col[i],alpha=0.25),border=NA)
lines(nt,E.Yhat_o,col=adjustcolor(col[i],0.75),lwd=2)
points(t,Y,pch=16,col=adjustcolor("black",0.75))
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*2],bty="n",cex=1.5)
legend("bottom",legend=colnames(TS)[-1][i],lty=1,col=col[i],lwd=2,bty="n",horiz=T)
#
## visualise temporal derivative
plot(nt,rep(0,length(nt)),ylim=c(-1,1)*max(abs(E.ddt.Yhat_o))*2,type="l",lty=3,xlab=xlab[2],ylab=if(i == 1)ylab[2]else"")
polygon(c(nt,rev(nt)),c(q05.ddt.Yhat_o,rev(q95.ddt.Yhat_o)),col=adjustcolor(col[i],alpha=0.25),border=NA)
##
Yhat_o_     = TS[,-1]
ddt.Yhat_o_ = apply(TS[,-1],2,diff)
ddt.Yhat_o_
ddt.Yhat_o_ = rbind(ddt.Yhat_o_,NA)
Yhat_o = list()
ddt.Yhat_o = list()
for(i in 1:N)
{
Yhat_o[[i]] = t(Yhat_o_[,i])
ddt.Yhat_o[[i]] = t(ddt.Yhat_o_[,i])
}
plotModel_o(TS,alpha_i,Yhat_o,ddt.Yhat_o)
Yhat_o_     = TS[,-1]
ddt.Yhat_o_ = apply(TS[,-1],2,diff)
ddt.Yhat_o_ = rbind(ddt.Yhat_o_[1,],ddt.Yhat_o_)
Yhat_o = list()
ddt.Yhat_o = list()
for(i in 1:N)
{
Yhat_o[[i]] = t(Yhat_o_[,i])
ddt.Yhat_o[[i]] = t(ddt.Yhat_o_[,i])
}
plotModel_o(TS,alpha_i,Yhat_o,ddt.Yhat_o)
##
Yhat_o_     = TS[,-1]
ddt.Yhat_o_ = apply(TS[,-1],2,diff)
ddt.Yhat_o_ = rbind(ddt.Yhat_o_,ddt.Yhat_o_[nrow(ddt.Yhat_o_),])
Yhat_o = list()
ddt.Yhat_o = list()
for(i in 1:N)
{
Yhat_o[[i]] = t(Yhat_o_[,i])
ddt.Yhat_o[[i]] = t(ddt.Yhat_o_[,i])
}
plotModel_o(TS,alpha_i,Yhat_o,ddt.Yhat_o)
## parameters of process model
K_p   = 3                                                       # number of models to fit
W_p   = rep(10,N)                                               # number of neurons in single layer perceptron (SLP)
N_p   = 2 * W_p * (2+N)                                         # number of parameters in process model
sd1_p = 0.1                                                     # standard deviation of model likelihood
sd2_p = list(c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2))) # standard deviation of prior distributions (second half concerns nonlinear functions)
## train process model
model_p    = trainModel_p(Yhat_o,ddt.Yhat_o,N_p,sd1_p,sd2_p,K_p)
Yhat_p     = model_p$Yhat_p
ddx.Yhat_p = model_p$ddx.Yhat_p
Geber_p    = model_p$Geber_p
Omega_p    = model_p$Omega_p
plotModel_p(TS,alpha_i,Yhat_p,ddx.Yhat_p,Geber_p)
## load data
attach(loadData_o(TS,alpha_i),warn.conflicts=F)
attach(loadData_p(Yhat_o,ddt.Yhat_o),warn.conflicts=F)
col   = (rainbow(N,start=0.1,end=0.9))
xlab  = c("","","Time")
ylab  = c("P.c. growth rate","Effects","Contributions")
index = c("a.","b.","c.","d.","e.","f.","g.","h.","i.","j.","k.","l.","m.","n.","o.","p.","q.","r.","s.","t.","u.","v.","w.","x.","y.","z.")
legend = paste(colnames(TS)[-1])
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
layout(cbind(c(1,2,3),c(4,5,6),c(7,8,9))[,1:min(3,N)])
## predictions
E.Yhat_p       = apply(Yhat_p[[i]],2,mean)
q05.Yhat_p     = apply(Yhat_p[[i]],2,quantile,p=0.05)
q95.Yhat_p     = apply(Yhat_p[[i]],2,quantile,p=0.95)
E.ddx.Yhat_p   = t(matrix(apply(ddx.Yhat_p[[i]],2,mean),ncol=nrow(X)))
q05.ddx.Yhat_p = t(matrix(apply(ddx.Yhat_p[[i]],2,quantile,p=0.05),ncol=nrow(X)))
q95.ddx.Yhat_p = t(matrix(apply(ddx.Yhat_p[[i]],2,quantile,p=0.95),ncol=nrow(X)))
E.Geber_p      = t(matrix(apply(Geber_p[[i]],2,mean),ncol=nrow(X)))
q05.Geber_p    = t(matrix(apply(Geber_p[[i]],2,quantile,p=0.05),ncol=nrow(X)))
q95.Geber_p    = t(matrix(apply(Geber_p[[i]],2,quantile,p=0.95),ncol=nrow(X)))
#
## dynamics
x = nt
y = Y[,i]
Y
plot(x,rep(0,length(x)),ylim=c(-1,1)*max(abs(y))*1.5,type="l",lty=3,xlab=xlab[1],ylab=if(i==1)ylab[1]else"")
points(x,y,pch=16,col=adjustcolor("black",0.75))
polygon(c(nt,rev(nt)),c(q05.Yhat_p,rev(q95.Yhat_p)),col=adjustcolor(col[i],alpha=0.2),border=NA)
lines(nt,E.Yhat_p,col=adjustcolor(col[i],alpha=0.75),lwd=2)
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*(3)],bty="n",cex=1.5)
plot(nt,rep(0,length(nt)),ylim=c(-1,1)*max(abs(E.ddx.Yhat_p))*1.5,type="l",lty=3,xlab=xlab[2],ylab=if(i==1)ylab[2]else"")
for(j in 1:N) lines(nt,E.ddx.Yhat_p[,j],col=adjustcolor(col[j],alpha=0.75),lwd=2)
for(j in 1:N) polygon(c(nt,rev(nt)),c(q05.ddx.Yhat_p[,j],rev(q95.ddx.Yhat_p[,j])),col=adjustcolor(col[j],alpha=0.2),border=NA)
if(!is.null(index))  legend("topright",legend=index[2+(i-1)*(3)],bty="n",cex=1.5)
plot(nt,rep(0,length(nt)),ylim=c(-1,1)*max(abs(E.Geber_p))*1.5,type="l",lty=3,xlab=xlab[3],ylab=if(i==1)ylab[3]else"")
for(j in 1:N) lines(nt, E.Geber_p[,j],col=adjustcolor(col[j],alpha=0.75),lwd=2)
for(j in 1:N) polygon(c(nt,rev(nt)),c(q05.Geber_p[,j],rev(q95.Geber_p[,j])),col=adjustcolor(col[j],alpha=0.2),border=NA)
if(!is.null(index))  legend("topright",legend=index[3+(i-1)*(3)],bty="n",cex=1.5)
if(!is.null(legend)) legend("bottomleft" ,legend=legend[1:(N/2)],lty=1,col=adjustcolor(col,alpha=0.75)[1:(N/2)],bty="n",horiz=F,lwd=2)
if(!is.null(legend)) legend("bottomright"  ,legend=legend[((N/2)+1):N],lty=1,col=adjustcolor(col,alpha=0.75)[((N/2)+1):N],bty="n",horiz=F,lwd=2)
y = Y[,i]
Y
## load data
attach(loadData_o(TS,alpha_i),warn.conflicts=F)
TS
y = Y[,i]
Y
TS
1/Yhat_o[[j]]*ddt.Yhat_o[[j]]
apply(1/Yhat_o[[j]]*ddt.Yhat_o[[j]],2,mean
)
Y_p       = NULL
for(j in 1:N)
{
# ## select random ensemble element (for stochastic training)
# v       = sample(1:K_o,1)
# X_p     = cbind(X_p,        Yhat_o[[j]][v,])
# ddt.X_p = cbind(ddt.X_p,ddt.Yhat_o[[j]][v,])
# Y_p     = cbind(Y_p,1/Yhat_o[[j]][v,]*ddt.Yhat_o[[j]][v,])
## mean of ensemble
E.X_p     = cbind(E.X_p,     apply(Yhat_o[[j]],2,mean))
E.ddt.X_p = cbind(E.ddt.X_p, apply(ddt.Yhat_o[[j]],2,mean))
E.Y_p     = cbind(E.Y_p,     apply(1/Yhat_o[[j]]*ddt.Yhat_o[[j]],2,mean))
}
## predictive variable
E.X_p     = NULL
E.ddt.X_p = NULL
E.Y_p     = NULL
X_p       = NULL
ddt.X_p   = NULL
Y_p       = NULL
for(j in 1:N)
{
# ## select random ensemble element (for stochastic training)
# v       = sample(1:K_o,1)
# X_p     = cbind(X_p,        Yhat_o[[j]][v,])
# ddt.X_p = cbind(ddt.X_p,ddt.Yhat_o[[j]][v,])
# Y_p     = cbind(Y_p,1/Yhat_o[[j]][v,]*ddt.Yhat_o[[j]][v,])
## mean of ensemble
E.X_p     = cbind(E.X_p,     apply(Yhat_o[[j]],2,mean))
E.ddt.X_p = cbind(E.ddt.X_p, apply(ddt.Yhat_o[[j]],2,mean))
E.Y_p     = cbind(E.Y_p,     apply(1/Yhat_o[[j]]*ddt.Yhat_o[[j]],2,mean))
}
E.Y_p
attach(loadData_p(Yhat_o,ddt.Yhat_o),warn.conflicts=F)
Y
Yhat_o
ddt.Yhat_o
Yhat_o
## data specs
N   = length(Yhat_o)
n   = ncol(Yhat_o[[1]])
K_o = nrow(Yhat_o[[1]])
## predictive variable
E.X_p     = NULL
E.ddt.X_p = NULL
E.Y_p     = NULL
X_p       = NULL
ddt.X_p   = NULL
Y_p       = NULL
for(j in 1:N)
{
# ## select random ensemble element (for stochastic training)
# v       = sample(1:K_o,1)
# X_p     = cbind(X_p,        Yhat_o[[j]][v,])
# ddt.X_p = cbind(ddt.X_p,ddt.Yhat_o[[j]][v,])
# Y_p     = cbind(Y_p,1/Yhat_o[[j]][v,]*ddt.Yhat_o[[j]][v,])
## mean of ensemble
E.X_p     = cbind(E.X_p,     apply(Yhat_o[[j]],2,mean))
E.ddt.X_p = cbind(E.ddt.X_p, apply(ddt.Yhat_o[[j]],2,mean))
E.Y_p     = cbind(E.Y_p,     apply(1/Yhat_o[[j]]*ddt.Yhat_o[[j]],2,mean))
}
## variables
X     = E.X_p
ddt.X = E.ddt.X_p
Y     = E.Y_p
Y
loadData_p = function(Yhat_o,ddt.Yhat_o)
{
## data specs
N   = length(Yhat_o)
n   = ncol(Yhat_o[[1]])
K_o = nrow(Yhat_o[[1]])
## predictive variable
E.X_p     = NULL
E.ddt.X_p = NULL
E.Y_p     = NULL
X_p       = NULL
ddt.X_p   = NULL
Y_p       = NULL
for(j in 1:N)
{
# ## select random ensemble element (for stochastic training)
# v       = sample(1:K_o,1)
# X_p     = cbind(X_p,        Yhat_o[[j]][v,])
# ddt.X_p = cbind(ddt.X_p,ddt.Yhat_o[[j]][v,])
# Y_p     = cbind(Y_p,1/Yhat_o[[j]][v,]*ddt.Yhat_o[[j]][v,])
## mean of ensemble
E.X_p     = cbind(E.X_p,     apply(Yhat_o[[j]],2,mean))
E.ddt.X_p = cbind(E.ddt.X_p, apply(ddt.Yhat_o[[j]],2,mean))
E.Y_p     = cbind(E.Y_p,     apply(1/Yhat_o[[j]]*ddt.Yhat_o[[j]],2,mean))
}
## variables
X     = E.X_p
ddt.X = E.ddt.X_p
Y     = E.Y_p
## standardise predictive variables
X_     = X
mean_x = apply(E.X_p,2,mean)
sd_x   = apply(E.X_p,2,sd)
X_     = t((t(X_)-mean_x)/sd_x)
## standardise response variable
Y_     = Y
mean_y = apply(E.Y_p,2,mean)
sd_y   = apply(E.Y_p,2,sd)
Y_     = t((t(Y_)-mean_y)/sd_y)
## terminate
return(list("X"      = X,
"ddt.X"  = ddt.X,
"X_"     = X_,
"Y"      = Y,
"Y_"     = Y_,
"mean_x" = mean_x,
"sd_x"   = sd_x,
"mean_y" = mean_y,
"sd_y"   = sd_y
))
}
attach(loadData_p(Yhat_o,ddt.Yhat_o),warn.conflicts=F)
Y
col   = (rainbow(N,start=0.1,end=0.9))
xlab  = c("","","Time")
ylab  = c("P.c. growth rate","Effects","Contributions")
index = c("a.","b.","c.","d.","e.","f.","g.","h.","i.","j.","k.","l.","m.","n.","o.","p.","q.","r.","s.","t.","u.","v.","w.","x.","y.","z.")
legend = paste(colnames(TS)[-1])
par(mar=c(4,4.5,0,0),oma=c(1,1,1,1),cex.lab=1.5)
layout(cbind(c(1,2,3),c(4,5,6),c(7,8,9))[,1:min(3,N)])
E.Yhat_p       = apply(Yhat_p[[i]],2,mean)
q05.Yhat_p     = apply(Yhat_p[[i]],2,quantile,p=0.05)
q95.Yhat_p     = apply(Yhat_p[[i]],2,quantile,p=0.95)
E.ddx.Yhat_p   = t(matrix(apply(ddx.Yhat_p[[i]],2,mean),ncol=nrow(X)))
q05.ddx.Yhat_p = t(matrix(apply(ddx.Yhat_p[[i]],2,quantile,p=0.05),ncol=nrow(X)))
q95.ddx.Yhat_p = t(matrix(apply(ddx.Yhat_p[[i]],2,quantile,p=0.95),ncol=nrow(X)))
E.Geber_p      = t(matrix(apply(Geber_p[[i]],2,mean),ncol=nrow(X)))
q05.Geber_p    = t(matrix(apply(Geber_p[[i]],2,quantile,p=0.05),ncol=nrow(X)))
q95.Geber_p    = t(matrix(apply(Geber_p[[i]],2,quantile,p=0.95),ncol=nrow(X)))
#
## dynamics
x = nt
y = Y[,i]
plot(x,rep(0,length(x)),ylim=c(-1,1)*max(abs(y))*1.5,type="l",lty=3,xlab=xlab[1],ylab=if(i==1)ylab[1]else"")
points(x,y,pch=16,col=adjustcolor("black",0.75))
polygon(c(nt,rev(nt)),c(q05.Yhat_p,rev(q95.Yhat_p)),col=adjustcolor(col[i],alpha=0.2),border=NA)
lines(nt,E.Yhat_p,col=adjustcolor(col[i],alpha=0.75),lwd=2)
if(!is.null(index)) legend("topright",legend=index[1+(i-1)*(3)],bty="n",cex=1.5)
plot(nt,rep(0,length(nt)),ylim=c(-1,1)*max(abs(E.ddx.Yhat_p))*1.5,type="l",lty=3,xlab=xlab[2],ylab=if(i==1)ylab[2]else"")
for(j in 1:N) lines(nt,E.ddx.Yhat_p[,j],col=adjustcolor(col[j],alpha=0.75),lwd=2)
for(j in 1:N) polygon(c(nt,rev(nt)),c(q05.ddx.Yhat_p[,j],rev(q95.ddx.Yhat_p[,j])),col=adjustcolor(col[j],alpha=0.2),border=NA)
if(!is.null(index))  legend("topright",legend=index[2+(i-1)*(3)],bty="n",cex=1.5)
# if(!is.null(legend)) legend("bottom" ,legend=legend,lty=1,col=adjustcolor(col,alpha=0.75),bty="n",horiz=T,lwd=2)
#
## Geber
plot(nt,rep(0,length(nt)),ylim=c(-1,1)*max(abs(E.Geber_p))*1.5,type="l",lty=3,xlab=xlab[3],ylab=if(i==1)ylab[3]else"")
for(j in 1:N) lines(nt, E.Geber_p[,j],col=adjustcolor(col[j],alpha=0.75),lwd=2)
for(j in 1:N) polygon(c(nt,rev(nt)),c(q05.Geber_p[,j],rev(q95.Geber_p[,j])),col=adjustcolor(col[j],alpha=0.2),border=NA)
if(!is.null(index))  legend("topright",legend=index[3+(i-1)*(3)],bty="n",cex=1.5)
if(!is.null(legend)) legend("bottomleft" ,legend=legend[1:(N/2)],lty=1,col=adjustcolor(col,alpha=0.75)[1:(N/2)],bty="n",horiz=F,lwd=2)
if(!is.null(legend)) legend("bottomright"  ,legend=legend[((N/2)+1):N],lty=1,col=adjustcolor(col,alpha=0.75)[((N/2)+1):N],bty="n",horiz=F,lwd=2)
plotModel_p(TS,alpha_i,Yhat_p,ddx.Yhat_p,Geber_p)
## compute Jacobian and contribution matrix
MSq = function(x) mean(x^2)
prop = function(x) x/sum(x)
J = t(matrix(unlist(lapply(ddx.Yhat_p,function(x)apply(matrix(apply(x,2,mean),nrow=nrow(TS),byrow=T),2,mean))),ncol=ncol(TS)-1)) ## average across samples then average across time steps
C = t(matrix(unlist(lapply(Geber_p,   function(x)apply(matrix(apply(x,2,mean),nrow=nrow(TS),byrow=T),2,MSq))),ncol=ncol(TS)-1)) ## average across samples then take mean square across time steps
C = t(apply(C,1,prop))
## remove effects on surf and bot
J[1:2,] = 0
C[1:2,] = 0
J[,1:2] = 0
C[,1:2] = 0
## thresholding
hist(J)
hist(C)
J = J*(C>0.1)
C = C*(C>0.1)
## visualise
.plot.DIN(J,C,colnames(TS)[-1])
f_sigma_p     = expo
ddx.f_sigma_p = ddx.expo
## load NODE functions
source("f_NODE_GM_Rstudio.r")
## parameters of process model
K_p   = 3                                                       # number of models to fit
W_p   = rep(10,N)                                               # number of neurons in single layer perceptron (SLP)
N_p   = 2 * W_p * (2+N)                                         # number of parameters in process model
sd1_p = 0.1                                                     # standard deviation of model likelihood
sd2_p = list(c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2)),
c(rep(0.03,N_p[1]/2),rep(.03,N_p[1]/2))) # standard deviation of prior distributions (second half concerns nonlinear functions)
## train process model
model_p    = trainModel_p(Yhat_o,ddt.Yhat_o,N_p,sd1_p,sd2_p,K_p)
Yhat_p     = model_p$Yhat_p
ddx.Yhat_p = model_p$ddx.Yhat_p
Geber_p    = model_p$Geber_p
Omega_p    = model_p$Omega_p
plotModel_p(TS,alpha_i,Yhat_p,ddx.Yhat_p,Geber_p)
## compute Jacobian and contribution matrix
MSq = function(x) mean(x^2)
prop = function(x) x/sum(x)
J = t(matrix(unlist(lapply(ddx.Yhat_p,function(x)apply(matrix(apply(x,2,mean),nrow=nrow(TS),byrow=T),2,mean))),ncol=ncol(TS)-1)) ## average across samples then average across time steps
C = t(matrix(unlist(lapply(Geber_p,   function(x)apply(matrix(apply(x,2,mean),nrow=nrow(TS),byrow=T),2,MSq))),ncol=ncol(TS)-1)) ## average across samples then take mean square across time steps
C = t(apply(C,1,prop))
## remove effects on surf and bot
J[1:2,] = 0
C[1:2,] = 0
J[,1:2] = 0
C[,1:2] = 0
## thresholding
hist(J)
hist(C)
J = J*(C>0.1)
C = C*(C>0.1)
## visualise
.plot.DIN(J,C,colnames(TS)[-1])
par(mfrow=c(1))
par(mfrow=c(1,&))
par(mfrow=c(1,1))
## visualise
.plot.DIN(J,C,colnames(TS)[-1])
ddt.Yhat_o
## load data
TS = read.table("data/TS.csv",sep=",",header=T)
## extract column of interest
head(TS)
# TS = TS[,c(22,4,7:12)]
TS = TS[,c(22,2:18)]
head(TS)
## subset time series
s  = c(
"time_step",
"surf.t",
"bot.t",
"Aurelia.sp",
# "Engraulis.japonicus",
# "Plotosus.lineatus",
"Sebastes.inermis",
"Trachurus.japonicus",
"Girella.punctata",
"Pseudolabrus.sieboldi",
"Halichoeres.poecilopterus",
"Halichoeres.tenuispinnis",
# "Chaenogobius.gulosus",
"Pterogobius.zonoleucus",
"Tridentiger.trigonocephalus",
# "Siganus.fuscescens",
# "Sphyraena.pinguis",
"Rudarius.ercodes"
)
TS = TS[,s]
## visualise time series
par(mfrow=c(3,4))
for(i in 2:ncol(TS))
{
plot(TS[,1],TS[,i],type="l",xlab="Time step",ylab="Count",bty="n",main=colnames(TS)[i])
}
par(mfrow=c(1,1))
dev.off()
## visualise time series
par(mfrow=c(3,4))
for(i in 2:ncol(TS))
{
plot(TS[,1],TS[,i],type="l",xlab="Time step",ylab="Count",bty="n",main=colnames(TS)[i])
}
par(mfrow=c(1,1))
plot(TS)
source("f_NODE_GM_Rstudio.r")
## load data
TS = read.table("data/TS.csv",sep=",",header=T)
## extract column of interest
head(TS)
# TS = TS[,c(22,4,7:12)]
TS = TS[,c(22,2:18)]
head(TS)
## subset time series
s  = c(
"time_step",
"surf.t",
"bot.t",
"Aurelia.sp",
"Engraulis.japonicus", #
"Plotosus.lineatus", #
"Sebastes.inermis",
"Trachurus.japonicus",
"Girella.punctata",
"Pseudolabrus.sieboldi",
"Halichoeres.poecilopterus",
"Halichoeres.tenuispinnis",
"Chaenogobius.gulosus", #
"Pterogobius.zonoleucus",
"Tridentiger.trigonocephalus",
"Siganus.fuscescens", #
"Sphyraena.pinguis", #
"Rudarius.ercodes"
)
TS = TS[,s]
TS = TS[50:150,]
## visualise time series
par(mfrow=c(3,4))
for(i in 2:ncol(TS))
{
plot(TS[,1],TS[,i],type="l",xlab="Time step",ylab="Count",bty="n",main=colnames(TS)[i])
}
par(mfrow=c(1,1))
